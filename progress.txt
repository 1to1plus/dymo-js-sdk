

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Class for managing requests via iFrames.  Supports a number of
 * methods of transfer.
 *
 * Gets and Posts can be performed and the resultant page read in as text,
 * JSON, or from the HTML DOM.
 *
 * Using an iframe causes the throbber to spin, this is good for providing
 * feedback to the user that an action has occurred.
 *
 * Requests do not affect the history stack, see goog.History if you require
 * this behavior.
 *
 * The responseText and responseJson methods assume the response is plain,
 * text.  You can access the Iframe's DOM through responseXml if you need
 * access to the raw HTML.
 *
 * Tested:
 *    + FF2.0 (Win Linux)
 *    + IE6, IE7
 *    + Opera 9.1,
 *    + Chrome
 *    - Opera 8.5 fails because of no textContent and buggy innerText support
 *
 * NOTE: Safari doesn't fire the onload handler when loading plain text files
 *
 * This has been tested with Drip in IE to ensure memory usage is as constant
 * as possible. When making making thousands of requests, memory usage stays
 * constant for a while but then starts increasing (<500k for 2000
 * requests) -- this hasn't yet been tracked down yet, though it is cleared up
 * after a refresh.
 *
 *
 * BACKGROUND FILE UPLOAD:
 * By posting an arbitrary form through an IframeIo object, it is possible to
 * implement background file uploads.  Here's how to do it:
 *
 * - Create a form:
 *   <pre>
 *   &lt;form id="form" enctype="multipart/form-data" method="POST"&gt;
 *      &lt;input name="userfile" type="file" /&gt;
 *   &lt;/form&gt;
 *   </pre>
 *
 * - Have the user click the file input
 * - Create an IframeIo instance
 *   <pre>
 *   var io = new goog.net.IframeIo;
 *   goog.events.listen(io, goog.net.EventType.COMPLETE,
 *       function() { alert('Sent'); });
 *   io.sendFromForm(document.getElementById('form'));
 *   </pre>
 *
 *
 * INCREMENTAL LOADING:
 * Gmail sends down multiple script blocks which get executed as they are
 * received by the client. This allows incremental rendering of the thread
 * list and conversations.
 *
 * This requires collaboration with the server that is sending the requested
 * page back.  To set incremental loading up, you should:
 *
 * A) In the application code there should be an externed reference to
 * <code>handleIncrementalData()</code>.  e.g.
 * goog.exportSymbol('GG_iframeFn', goog.net.IframeIo.handleIncrementalData);
 *
 * B) The response page should them call this method directly, an example
 * response would look something like this:
 * <pre>
 *   &lt;html&gt;
 *   &lt;head&gt;
 *     &lt;meta content="text/html;charset=UTF-8" http-equiv="content-type"&gt;
 *   &lt;/head&gt;
 *   &lt;body&gt;
 *     &lt;script&gt;
 *       D = top.P ? function(d) { top.GG_iframeFn(window, d) } : function() {};
 *     &lt;/script&gt;
 *
 *     &lt;script&gt;D([1, 2, 3, 4, 5]);&lt;/script&gt;
 *     &lt;script&gt;D([6, 7, 8, 9, 10]);&lt;/script&gt;
 *     &lt;script&gt;D([11, 12, 13, 14, 15]);&lt;/script&gt;
 *   &lt;/body&gt;
 *   &lt;/html&gt;
 * </pre>
 *
 * Your application should then listen, on the IframeIo instance, to the event
 * goog.net.EventType.INCREMENTAL_DATA.  The event object contains a
 * 'data' member which is the content from the D() calls above.
 *
 * NOTE: There can be problems if you save a reference to the data object in IE.
 * If you save an array, and the iframe is dispose, then the array looses its
 * prototype and thus array methods like .join().  You can get around this by
 * creating arrays using the parent window's Array constructor, or you can
 * clone the array.
 *
 *
 * EVENT MODEL:
 * The various send methods work asynchronously. You can be notified about
 * the current status of the request (completed, success or error) by
 * listening for events on the IframeIo object itself. The following events
 * will be sent:
 * - goog.net.EventType.COMPLETE: when the request is completed
 *   (either sucessfully or unsuccessfully). You can find out about the result
 *   using the isSuccess() and getLastError
 *   methods.
 * - goog.net.EventType.SUCCESS</code>: when the request was completed
 *   successfully
 * - goog.net.EventType.ERROR: when the request failed
 * - goog.net.EventType.ABORT: when the request has been aborted
 *
 * Example:
 * <pre>
 * var io = new goog.net.IframeIo();
 * goog.events.listen(io, goog.net.EventType.COMPLETE,
 *   function() { alert('request complete'); });
 * io.sendFromForm(...);
 * </pre>
 *
 */






























/**
 * Class for managing requests via iFrames.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.net.IframeIo = function() {
  goog.net.IframeIo.base(this, 'constructor');

  /**
   * Name for this IframeIo and frame
   * @type {string}
   * @private
   */
  this.name_ = goog.net.IframeIo.getNextName_();

  /**
   * An array of iframes that have been finished with.  We need them to be
   * disposed async, so we don't confuse the browser (see below).
   * @type {Array<Element>}
   * @private
   */
  this.iframesForDisposal_ = [];

  // Create a lookup from names to instances of IframeIo.  This is a helper
  // function to be used in conjunction with goog.net.IframeIo.getInstanceByName
  // to find the IframeIo object associated with a particular iframe.  Used in
  // incremental scripts etc.
  goog.net.IframeIo.instances_[this.name_] = this;

};
goog.inherits(goog.net.IframeIo, goog.events.EventTarget);


/**
 * Object used as a map to lookup instances of IframeIo objects by name.
 * @type {Object}
 * @private
 */
goog.net.IframeIo.instances_ = {};


/**
 * Prefix for frame names
 * @type {string}
 */
goog.net.IframeIo.FRAME_NAME_PREFIX = 'closure_frame';


/**
 * Suffix that is added to inner frames used for sending requests in non-IE
 * browsers
 * @type {string}
 */
goog.net.IframeIo.INNER_FRAME_SUFFIX = '_inner';


/**
 * The number of milliseconds after a request is completed to dispose the
 * iframes.  This can be done lazily so we wait long enough for any processing
 * that occurred as a result of the response to finish.
 * @type {number}
 */
goog.net.IframeIo.IFRAME_DISPOSE_DELAY_MS = 2000;


/**
 * Counter used when creating iframes
 * @type {number}
 * @private
 */
goog.net.IframeIo.counter_ = 0;


/**
 * Form element to post to.
 * @type {HTMLFormElement}
 * @private
 */
goog.net.IframeIo.form_;


/**
 * Static send that creates a short lived instance of IframeIo to send the
 * request.
 * @param {goog.Uri|string} uri Uri of the request, it is up the caller to
 *     manage query string params.
 * @param {Function=} opt_callback Event handler for when request is completed.
 * @param {string=} opt_method Default is GET, POST uses a form to submit the
 *     request.
 * @param {boolean=} opt_noCache Append a timestamp to the request to avoid
 *     caching.
 * @param {Object|goog.structs.Map=} opt_data Map of key-value pairs that
 *     will be posted to the server via the iframe's form.
 */
goog.net.IframeIo.send = function(
    uri, opt_callback, opt_method, opt_noCache, opt_data) {

  var io = new goog.net.IframeIo();
  goog.events.listen(io, goog.net.EventType.READY, io.dispose, false, io);
  if (opt_callback) {
    goog.events.listen(io, goog.net.EventType.COMPLETE, opt_callback);
  }
  io.send(uri, opt_method, opt_noCache, opt_data);
};


/**
 * Find an iframe by name (assumes the context is goog.global since that is
 * where IframeIo's iframes are kept).
 * @param {string} fname The name to find.
 * @return {HTMLIFrameElement} The iframe element with that name.
 */
goog.net.IframeIo.getIframeByName = function(fname) {
  return window.frames[fname];
};


/**
 * Find an instance of the IframeIo object by name.
 * @param {string} fname The name to find.
 * @return {goog.net.IframeIo} The instance of IframeIo.
 */
goog.net.IframeIo.getInstanceByName = function(fname) {
  return goog.net.IframeIo.instances_[fname];
};


/**
 * Handles incremental data and routes it to the correct iframeIo instance.
 * The HTML page requested by the IframeIo instance should contain script blocks
 * that call an externed reference to this method.
 * @param {Window} win The window object.
 * @param {Object} data The data object.
 */
goog.net.IframeIo.handleIncrementalData = function(win, data) {
  // If this is the inner-frame, then we need to use the parent instead.
  var iframeName = goog.string.endsWith(win.name,
      goog.net.IframeIo.INNER_FRAME_SUFFIX) ? win.parent.name : win.name;

  var iframeIoName = iframeName.substring(0, iframeName.lastIndexOf('_'));
  var iframeIo = goog.net.IframeIo.getInstanceByName(iframeIoName);
  if (iframeIo && iframeName == iframeIo.iframeName_) {
    iframeIo.handleIncrementalData_(data);
  } else {
    var logger = goog.log.getLogger('goog.net.IframeIo');
    goog.log.info(logger,
        'Incremental iframe data routed for unknown iframe');
  }
};


/**
 * @return {string} The next iframe name.
 * @private
 */
goog.net.IframeIo.getNextName_ = function() {
  return goog.net.IframeIo.FRAME_NAME_PREFIX + goog.net.IframeIo.counter_++;
};


/**
 * Gets a static form, one for all instances of IframeIo since IE6 leaks form
 * nodes that are created/removed from the document.
 * @return {!HTMLFormElement} The static form.
 * @private
 */
goog.net.IframeIo.getForm_ = function() {
  if (!goog.net.IframeIo.form_) {
    goog.net.IframeIo.form_ = /** @type {!HTMLFormElement} */ (
        goog.dom.createDom(goog.dom.TagName.FORM));
    goog.net.IframeIo.form_.acceptCharset = 'utf-8';

    // Hide the form and move it off screen
    var s = goog.net.IframeIo.form_.style;
    s.position = 'absolute';
    s.visibility = 'hidden';
    s.top = s.left = '-10px';
    s.width = s.height = '10px';
    s.overflow = 'hidden';

    goog.dom.getDocument().body.appendChild(goog.net.IframeIo.form_);
  }
  return goog.net.IframeIo.form_;
};


/**
 * Adds the key value pairs from a map like data structure to a form
 * @param {HTMLFormElement} form The form to add to.
 * @param {Object|goog.structs.Map|goog.Uri.QueryData} data The data to add.
 * @private
 */
goog.net.IframeIo.addFormInputs_ = function(form, data) {
  var helper = goog.dom.getDomHelper(form);
  goog.structs.forEach(data, function(value, key) {
    var inp = helper.createDom(goog.dom.TagName.INPUT,
        {'type': goog.dom.InputType.HIDDEN, 'name': key, 'value': value});
    form.appendChild(inp);
  });
};


/**
 * @return {boolean} Whether we can use readyState to monitor iframe loading.
 * @private
 */
goog.net.IframeIo.useIeReadyStateCodePath_ = function() {
  // ReadyState is only available on iframes up to IE10.
  return goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('11');
};


/**
 * Reference to a logger for the IframeIo objects
 * @type {goog.log.Logger}
 * @private
 */
goog.net.IframeIo.prototype.logger_ =
    goog.log.getLogger('goog.net.IframeIo');


/**
 * Reference to form element that gets reused for requests to the iframe.
 * @type {HTMLFormElement}
 * @private
 */
goog.net.IframeIo.prototype.form_ = null;


/**
 * Reference to the iframe being used for the current request, or null if no
 * request is currently active.
 * @type {HTMLIFrameElement}
 * @private
 */
goog.net.IframeIo.prototype.iframe_ = null;


/**
 * Name of the iframe being used for the current request, or null if no
 * request is currently active.
 * @type {?string}
 * @private
 */
goog.net.IframeIo.prototype.iframeName_ = null;


/**
 * Next id so that iframe names are unique.
 * @type {number}
 * @private
 */
goog.net.IframeIo.prototype.nextIframeId_ = 0;


/**
 * Whether the object is currently active with a request.
 * @type {boolean}
 * @private
 */
goog.net.IframeIo.prototype.active_ = false;


/**
 * Whether the last request is complete.
 * @type {boolean}
 * @private
 */
goog.net.IframeIo.prototype.complete_ = false;


/**
 * Whether the last request was a success.
 * @type {boolean}
 * @private
 */
goog.net.IframeIo.prototype.success_ = false;


/**
 * The URI for the last request.
 * @type {goog.Uri}
 * @private
 */
goog.net.IframeIo.prototype.lastUri_ = null;


/**
 * The text content of the last request.
 * @type {?string}
 * @private
 */
goog.net.IframeIo.prototype.lastContent_ = null;


/**
 * Last error code
 * @type {goog.net.ErrorCode}
 * @private
 */
goog.net.IframeIo.prototype.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;


/**
 * Window timeout ID used to detect when firefox silently fails.
 * @type {?number}
 * @private
 */
goog.net.IframeIo.prototype.firefoxSilentErrorTimeout_ = null;


/**
 * Window timeout ID used by the timer that disposes the iframes.
 * @type {?number}
 * @private
 */
goog.net.IframeIo.prototype.iframeDisposalTimer_ = null;


/**
 * This is used to ensure that we don't handle errors twice for the same error.
 * We can reach the {@link #handleError_} method twice in IE if the form is
 * submitted while IE is offline and the URL is not available.
 * @type {boolean}
 * @private
 */
goog.net.IframeIo.prototype.errorHandled_;


/**
 * Whether to suppress the listeners that determine when the iframe loads.
 * @type {boolean}
 * @private
 */
goog.net.IframeIo.prototype.ignoreResponse_ = false;


/** @private {Function} */
goog.net.IframeIo.prototype.errorChecker_;


/** @private {Object} */
goog.net.IframeIo.prototype.lastCustomError_;


/** @private {?string} */
goog.net.IframeIo.prototype.lastContentHtml_;


/**
 * Sends a request via an iframe.
 *
 * A HTML form is used and submitted to the iframe, this simplifies the
 * difference between GET and POST requests. The iframe needs to be created and
 * destroyed for each request otherwise the request will contribute to the
 * history stack.
 *
 * sendFromForm does some clever trickery (thanks jlim) in non-IE browsers to
 * stop a history entry being added for POST requests.
 *
 * @param {goog.Uri|string} uri Uri of the request.
 * @param {string=} opt_method Default is GET, POST uses a form to submit the
 *     request.
 * @param {boolean=} opt_noCache Append a timestamp to the request to avoid
 *     caching.
 * @param {Object|goog.structs.Map=} opt_data Map of key-value pairs.
 */
goog.net.IframeIo.prototype.send = function(
    uri, opt_method, opt_noCache, opt_data) {

  if (this.active_) {
    throw Error('[goog.net.IframeIo] Unable to send, already active.');
  }

  var uriObj = new goog.Uri(uri);
  this.lastUri_ = uriObj;
  var method = opt_method ? opt_method.toUpperCase() : 'GET';

  if (opt_noCache) {
    uriObj.makeUnique();
  }

  goog.log.info(this.logger_,
      'Sending iframe request: ' + uriObj + ' [' + method + ']');

  // Build a form for this request
  this.form_ = goog.net.IframeIo.getForm_();

  if (method == 'GET') {
    // For GET requests, we assume that the caller didn't want the queryparams
    // already specified in the URI to be clobbered by the form, so we add the
    // params here.
    goog.net.IframeIo.addFormInputs_(this.form_, uriObj.getQueryData());
  }

  if (opt_data) {
    // Create form fields for each of the data values
    goog.net.IframeIo.addFormInputs_(this.form_, opt_data);
  }

  // Set the URI that the form will be posted
  this.form_.action = uriObj.toString();
  this.form_.method = method;

  this.sendFormInternal_();
  this.clearForm_();
};


/**
 * Sends the data stored in an existing form to the server. The HTTP method
 * should be specified on the form, the action can also be specified but can
 * be overridden by the optional URI param.
 *
 * This can be used in conjunction will a file-upload input to upload a file in
 * the background without affecting history.
 *
 * Example form:
 * <pre>
 *   &lt;form action="/server/" enctype="multipart/form-data" method="POST"&gt;
 *     &lt;input name="userfile" type="file"&gt;
 *   &lt;/form&gt;
 * </pre>
 *
 * @param {HTMLFormElement} form Form element used to send the request to the
 *     server.
 * @param {string=} opt_uri Uri to set for the destination of the request, by
 *     default the uri will come from the form.
 * @param {boolean=} opt_noCache Append a timestamp to the request to avoid
 *     caching.
 */
goog.net.IframeIo.prototype.sendFromForm = function(form, opt_uri,
    opt_noCache) {
  if (this.active_) {
    throw Error('[goog.net.IframeIo] Unable to send, already active.');
  }

  var uri = new goog.Uri(opt_uri || form.action);
  if (opt_noCache) {
    uri.makeUnique();
  }

  goog.log.info(this.logger_, 'Sending iframe request from form: ' + uri);

  this.lastUri_ = uri;
  this.form_ = form;
  this.form_.action = uri.toString();
  this.sendFormInternal_();
};


/** @override */
goog.net.IframeIo.prototype.disposeInternal = function() {
  goog.log.fine(this.logger_, 'Disposing iframeIo instance');

  // If there is an active request, abort it
  if (this.active_) {
    goog.log.fine(this.logger_, 'Aborting active request');
    this.abort();
  }

  // Call super-classes implementation (remove listeners)
  goog.net.IframeIo.superClass_.disposeInternal.call(this);

  // Add the current iframe to the list of iframes for disposal.
  if (this.iframe_) {
    this.scheduleIframeDisposal_();
  }

  // Disposes of the form
  this.disposeForm_();

  // Nullify anything that might cause problems and clear state
  delete this.errorChecker_;
  this.form_ = null;
  this.lastCustomError_ = this.lastContent_ = this.lastContentHtml_ = null;
  this.lastUri_ = null;
  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;

  delete goog.net.IframeIo.instances_[this.name_];
};



/**
 * Sets whether to ignore the response from the server by not adding any event
 * handlers to fire when the iframe loads. This is necessary when using IframeIo
 * to submit to a server on another domain, to avoid same-origin violations when
 * trying to access the response. If this is set to true, the IframeIo instance
 * will be a single-use instance that is only usable for one request.  It will
 * only clean up its resources (iframes and forms) when it is disposed.
 * @param {boolean} ignore Whether to ignore the server response.
 */
goog.net.IframeIo.prototype.setIgnoreResponse = function(ignore) {
  this.ignoreResponse_ = ignore;
};


/**
 * A Delay object invokes the associated function after a specified delay. The
 * interval duration can be specified once in the constructor, or can be defined
 * each time the delay is started. Calling start on an active delay will reset
 * the timer.
 *
 * @param {function(this:THIS)} listener Function to call when the
 *     delay completes.
 * @param {number=} opt_interval The default length of the invocation delay (in
 *     milliseconds).
 * @param {THIS=} opt_handler The object scope to invoke the function in.
 * @template THIS
 * @constructor
 * @struct
 * @suppress {checkStructDictInheritance}
 * @extends {goog.Disposable}
 * @final
 */
goog.async.Delay = function(listener, opt_interval, opt_handler) {
  goog.async.Delay.base(this, 'constructor');

  /**
   * The function that will be invoked after a delay.
   * @private {function(this:THIS)}
   */
  this.listener_ = listener;

  /**
   * The default amount of time to delay before invoking the callback.
   * @type {number}
   * @private
   */
  this.interval_ = opt_interval || 0;

  /**
   * The object context to invoke the callback in.
   * @type {Object|undefined}
   * @private
   */
  this.handler_ = opt_handler;


  /**
   * Cached callback function invoked when the delay finishes.
   * @type {Function}
   * @private
   */
  this.callback_ = goog.bind(this.doAction_, this);
};
goog.inherits(goog.async.Delay, goog.Disposable);



/**
 * A deprecated alias.
 * @deprecated Use goog.async.Delay instead.
 * @constructor
 * @final
 */
goog.Delay = goog.async.Delay;


/**
 * Identifier of the active delay timeout, or 0 when inactive.
 * @type {number}
 * @private
 */
goog.async.Delay.prototype.id_ = 0;


/**
 * Disposes of the object, cancelling the timeout if it is still outstanding and
 * removing all object references.
 * @override
 * @protected
 */
goog.async.Delay.prototype.disposeInternal = function() {
  goog.async.Delay.base(this, 'disposeInternal');
  this.stop();
  delete this.listener_;
  delete this.handler_;
};


/**
 * Starts the delay timer. The provided listener function will be called after
 * the specified interval. Calling start on an active timer will reset the
 * delay interval.
 * @param {number=} opt_interval If specified, overrides the object's default
 *     interval with this one (in milliseconds).
 */
goog.async.Delay.prototype.start = function(opt_interval) {
  this.stop();
  this.id_ = goog.Timer.callOnce(
      this.callback_,
      goog.isDef(opt_interval) ? opt_interval : this.interval_);
};


/**
 * Stops the delay timer if it is active. No action is taken if the timer is not
 * in use.
 */
goog.async.Delay.prototype.stop = function() {
  if (this.isActive()) {
    goog.Timer.clear(this.id_);
  }
  this.id_ = 0;
};


/**
 * Fires delay's action even if timer has already gone off or has not been
 * started yet; guarantees action firing. Stops the delay timer.
 */
goog.async.Delay.prototype.fire = function() {
  this.stop();
  this.doAction_();
};


/**
 * Fires delay's action only if timer is currently active. Stops the delay
 * timer.
 */
goog.async.Delay.prototype.fireIfActive = function() {
  if (this.isActive()) {
    this.fire();
  }
};


/**
 * @return {boolean} True if the delay is currently active, false otherwise.
 */
goog.async.Delay.prototype.isActive = function() {
  return this.id_ != 0;
};


/**
 * Invokes the callback function after the delay successfully completes.
 * @private
 */
goog.async.Delay.prototype.doAction_ = function() {
  this.id_ = 0;
  if (this.listener_) {
    this.listener_.call(this.handler_);
  }
};

/*
* Generate a RFC4122(v4) UUID
*
* based on https://github.com/broofa/node-uuid
*/




//----------------------------------------------------------------------------
//
//  $Id: NetworkPrinter.js 15739 2011-08-11 15:56:29Z vbuzuev $ 
//
// Project -------------------------------------------------------------------
//
//  DYMO Label Framework JavaScript Library
//
// Content -------------------------------------------------------------------
//
//  PrintJob class
//
//----------------------------------------------------------------------------
//
//  Copyright (c), 2010, Sanford, L.P. All Rights Reserved.
//
//----------------------------------------------------------------------------






/**
    Contains a pair of printer uri and printer' local name
    @constructor

    @param {string} printerUri
    @param {string} printerName
*/
dymo.label.framework.NetworkPrinterName = function(printerUri, printerName) 
{
    this.printerUri = printerUri;
    this.printerName = printerName;
}


/** Determines is the printer local or network
 Local means installed as a Printer on the Desktop machine 
 where java script is executing, e.g. it is a printer available as 'printer' on Windows machine
 'Network' means a printer installed on a 'proxy' machine or a real network printer (in the future)

    @param {string} printerName
    @return {boolean}
*/
dymo.label.framework.NetworkPrinterName.isNetworkPrinter = function(printerName)
{
    // a network printer should have a valid uri with 'dymo' as the uri's scheme
    var printerUri = new goog.Uri(printerName);
    return printerUri.hasScheme() && printerUri.hasDomain() && printerUri.hasPath();
}



/** Splits network printer name into two parts, the printer's uri and a 
 'local' printer name

 @param {string} networkPrinterName
 @return {dymo.label.framework.NetworkPrinterName} 
*/
dymo.label.framework.NetworkPrinterName.splitNetworkPrinterName = function(networkPrinterName)
{
    var uri = new goog.Uri(networkPrinterName);
    var printerName = uri.getPath();
    if (printerName.length > 1 && printerName.charAt(0) == '/')
        printerName = printerName.slice(1);

    uri.setPath('');

    return new dymo.label.framework.NetworkPrinterName(uri.toString(), printerName);
}



// adds a hidden element to load DYMO Safari plugin
// returns js object represent the plugin
/**
    @return {SafariPlugin}
*/
function _createSafariPlugin()
{
    if (ASSUME_MOBILE)
        return null;

    var pluginId = '_DymoLabelFrameworkJslSafariPlugin';
            
    if (!document.getElementById(pluginId))
    {
        // try to create Safari Plugin as <embed> control
        var safariPlugin = document.createElement("embed");
        safariPlugin.type = "application/x-dymolabel";
        safariPlugin.id = pluginId;
        safariPlugin.width = 1;
        safariPlugin.height = 1;
        safariPlugin.hidden = true;

        // it is important to add it to the DOM
        // otherwise _DymoLabelFrameworkJslSafariPlugin is unavailable and 
        // it is impossible to call plug-in methods
        document.body.appendChild(safariPlugin);
    }
    
    return window[pluginId];
}

// adds a hidden element to load DYMO Safari plugin
// returns js object represent the plugin
/**
    @private
    @return {NsapiPlugin|HTMLElement}
*/
function _createNsapiPlugin2(hidden)
{
    if (ASSUME_MOBILE)
        return null;

    var pluginId = '_DymoLabelFrameworkJslPlugin';
            
    if (!document.getElementById(pluginId))
    {
        // try to create Safari Plugin as <embed> control
        var plugin = document.createElement("embed");
        plugin.type = "application/x-dymolabel";
        plugin.id = pluginId;

        if (hidden)
        {
            plugin.width = 1;
            plugin.height = 1;
            plugin.hidden = true;
        }
        else
        {
            plugin.width = 0;
            plugin.height = 0;
            plugin.hidden = false;
        }

        // it is important to add it to the DOM
        // otherwise _DymoLabelFrameworkJslSafariPlugin is unavailable and 
        // it is impossible to call plug-in methods
        document.body.appendChild(plugin);
    }
    
    //return _DymoLabelFrameworkJslSafariPlugin;
    return document.getElementById(pluginId);
}

// adds a hidden element to load DYMO Safari plugin
// returns js object represent the plugin
/**
    @private
    @return {NsapiPlugin|HTMLElement}
*/
function _createNsapiPlugin()
{
    if (ASSUME_MOBILE)
        return null;

    var result = _createNsapiPlugin2(true);
    if (!result.getPrinters)
    {
        document.body.removeChild(result); 
        result = _createNsapiPlugin2(false);
    }

    return result;

}


// adds a hidden element to load DYMO NPAPI plugin
// returns js object represent the plugin
/**
    @private
    @return {NsapiPlugin|HTMLElement}
*/
function _createMacNsapiPlugin2(hidden)
{
    if (ASSUME_MOBILE)
        return null;

    var pluginId = '_DymoLabelFrameworkJslPlugin';
            
    if (!document.getElementById(pluginId))
    {
        // try to create Safari Plugin as <embed> control
        var plugin = document.createElement("embed");
        plugin.type = "application/x-npapi-dymolabel";
        plugin.id = pluginId;
        if (hidden)
        {
            plugin.width = 1;
            plugin.height = 1;
            plugin.hidden = true;
        }
        else
        {
            plugin.width = 0;
            plugin.height = 0;
            plugin.hidden = false;
        }

        // it is important to add it to the DOM
        // otherwise _DymoLabelFrameworkJslSafariPlugin is unavailable and 
        // it is impossible to call plug-in methods
        document.body.appendChild(plugin);

        if (!plugin.getPrinters)
        {
            plugin.width = 1;
            plugin.height = 1;
            plugin.hidden = false;
        }
    }
    
    //return _DymoLabelFrameworkJslSafariPlugin;
    return document.getElementById(pluginId);
}

// adds a hidden element to load DYMO Safari plugin
// returns js object represent the plugin
/**
    @return {NsapiPlugin|HTMLElement}
*/
function _createMacNsapiPlugin()
{
    if (ASSUME_MOBILE)
        return null;

    var result = _createMacNsapiPlugin2(true);
    if (!result.getPrinters)
    {
        document.body.removeChild(result); 
        result = _createMacNsapiPlugin2(false);
    }

    return result;

}



/**
  @export
 */
dymo.label.framework.init = function(callBack)
{
    _createFramework(callBack, true);
}
//----------------------------------------------------------------------------
//
//  $Id: DYMO.Label.Framework.js 12271 2010-06-16 14:25:34Z vbuzuev $ 
//
// Project -------------------------------------------------------------------
//
//  DYMO Label Framework JavaScript Library
//
// Content -------------------------------------------------------------------
//
//  Main functions
//
//----------------------------------------------------------------------------
//
//  Copyright (c), 2010, Sanford, L.P. All Rights Reserved.
//
//----------------------------------------------------------------------------

/**
    @fileoverview PrinterInfo support
*/









//----------------------------------------------------------------------------
//
//  $Id: PrintJob.js 15739 2011-08-11 15:56:29Z vbuzuev $ 
//
// Project -------------------------------------------------------------------
//
//  DYMO Label Framework JavaScript Library
//
// Content -------------------------------------------------------------------
//
//  PrintJobStatus class
//
//----------------------------------------------------------------------------
//
//  Copyright (c), 2010, Sanford, L.P. All Rights Reserved.
//
//----------------------------------------------------------------------------


/** information about for one network printer
    @constructor
    @param {string} printerUri      uri to communicatino with the printer. Right now only Dymo Label Proxy service is supported
    @param {string} printerLocation printer location/description. Just a string used to format "name" for the end-user. If not specified, host name from printerUri will be used
    @param {string} printersXml 
*/
var NetworkPrinterInfo = function(printerUri, printerLocation, printersXml)
{
    this.printerUri = printerUri;
    this.printerLocation = printerLocation;
    this.printersXml = printersXml;
}

/**
    parses printers xml and returns appropriate PrinterInfo 
    @return {Array.<dymo.label.framework.PrinterInfo>}
*/
NetworkPrinterInfo.prototype.getPrinters = function()
{

    var result = getPrinters(this.printersXml);

    var uri = new goog.Uri(this.printerUri);
    var location = this.printerLocation;
    if (location == '')
        location = uri.getDomain();

    // update name to include location or hostname like
    // '<name> @ <location>'
    for (var i = 0; i < result.length; ++i)
    {
        var printerInfo = result[i];

        var name = printerInfo["name"];

        //result[i]["name"] = goog.uri.utils.appendPath(uri.toString(), name);
        printerInfo["name"] = name + ' @ ' + location;

        // set additional fields
        printerInfo.printerUri = this.printerUri;
        printerInfo.location = location;
        printerInfo.originalPrinterName = name;

        // 'publish' fields as well
        printerInfo['printerUri'] = printerInfo.printerUri;
        printerInfo['location'] = printerInfo.location;
        printerInfo['localName'] = printerInfo.originalPrinterName;
    }

    return result;
}


/**
    Adds a network printer/proxy to the library.
    Upon adding a request is made to the printer to get it configuration information 

    @export
   
    @param {string} printerUri printer uri 

    @param {string=} opt_location printer location 

    @param {function(string)=} opt_successCallback A function expecting one
     argument, called when the printer configuration information arrives, with the printer uri.
 
    @param {function(string)=} opt_errorCallback A function expecting one
       argument, called on timeout or other error

    @return {undefined}
*/
dymo.label.framework.addPrinterUri = function(printerUri, opt_location, opt_successCallback, opt_errorCallback)
{
    // check location
    var location = opt_location || '';
    if (!goog.isString(location))
        location = location.toString();

    var successCallback = function(printersXml)
    {
        var printerInfo = new NetworkPrinterInfo(printerUri, location, printersXml);
        _networkPrinters[printerUri] = printerInfo;

        if (opt_successCallback)
            opt_successCallback(printerUri);
    }

    var errorCallback = null;
    if (opt_errorCallback)
        errorCallback = function() {opt_errorCallback(printerUri);};

    var getPritnersUri = goog.uri.utils.appendPath(printerUri, 'getPrinters');

    var jsonp = new goog.net.Jsonp(getPritnersUri, 'callback');
    jsonp.send(null, successCallback, errorCallback); 
}

/**
    @export
    @param {string} printerUri 
    @return {undefined}
*/
dymo.label.framework.removePrinterUri = function(printerUri)
{
    delete _networkPrinters[printerUri];
    //for (var i = _networkPrinters.length - 1; i >= 0; --i)
    //    if (_networkPrinters[i].printerUri == printerUri)
    //        _networkPrinters.remove(i);
}

/**
    @export
    @return {undefined}
*/
dymo.label.framework.removeAllPrinterUri = function()
{
    _networkPrinters = {};
    //for (var i = _networkPrinters.length - 1; i >= 0; --i)
    //    if (_networkPrinters[i].printerUri == printerUri)
    //        _networkPrinters.remove(i);
}


/**
    parses printers xml and returns appropriate PrinterInfo 
    @private
    @return {Array.<dymo.label.framework.PrinterInfo>}
*/
function getPrinters(printersXml)
{
    //TODO: update to use functions from Xml namespace
    //var getXmlText = function(elem) { return elem.firstChild.data; };
    //var getChildText = function(elem, child) { return getXmlText(elem.getElementsByTagName(child)[0]); };
    var getChildText = function(elem, child) { return dymo.xml.getElementText(dymo.xml.getElement(elem, child)); };
 
    var xmldoc = dymo.xml.parse(printersXml);
    var result = createPrintersCollection();
    var i, name, modelName, isConnected, isLocal, isTwinTurbo, isAutoCutSupported;

    //TODO: update to use XPath
    //var printers = xmldoc.getElementsByTagName("Printers")[0];
    var printers = dymo.xml.getElement(xmldoc, "Printers");
    //var labelWriterPrinters = printers.getElementsByTagName("LabelWriterPrinter");
    var labelWriterPrinters = dymo.xml.getElements(printers, "LabelWriterPrinter");
    for (i = 0; i < labelWriterPrinters.length; i++)
    {
        //var labelWriterPrinter = {};
        //labelWriterPrinter.printerType = "LabelWriterPrinter";
        name = getChildText(labelWriterPrinters[i], "Name");
        modelName = getChildText(labelWriterPrinters[i], "ModelName");
        isConnected = getChildText(labelWriterPrinters[i], "IsConnected") == "True";
        isLocal = getChildText(labelWriterPrinters[i], "IsLocal") == "True";
        isTwinTurbo = getChildText(labelWriterPrinters[i], "IsTwinTurbo") == "True";

        var labelWriterPrinterInfo = new dymo.label.framework.LabelWriterPrinterInfo(name, modelName, isConnected, isLocal, isTwinTurbo);
         addPrinterToCollection(labelWriterPrinterInfo, result);
    }

    //var tapePrinters = printers.getElementsByTagName("TapePrinter");
    var tapePrinters = dymo.xml.getElements(printers, "TapePrinter");
    for (i = 0; i < tapePrinters.length; i++)
    {
        //var tapePrinter = {};
        //tapePrinter.printerType = "TapePrinter";
        name = getChildText(tapePrinters[i], "Name");
        modelName = getChildText(tapePrinters[i], "ModelName");
        isConnected = getChildText(tapePrinters[i], "IsConnected") == "True";
        isLocal = getChildText(tapePrinters[i], "IsLocal") == "True";
        isAutoCutSupported = getChildText(tapePrinters[i], "IsAutoCutSupported") == "True";

        var tapePrinterInfo = new dymo.label.framework.TapePrinterInfo(name, modelName, isConnected, isLocal, isAutoCutSupported);
        addPrinterToCollection(tapePrinterInfo, result);
    }

    //var dzPrinters = printers.getElementsByTagName("DZPrinter");
    var dzPrinters = dymo.xml.getElements(printers, "DZPrinter");
    for (i = 0; i < dzPrinters.length; i++)
    {
        //var dzPrinter = {};
        //dzPrinter.printerType = "DZPrinter";
        name = getChildText(dzPrinters[i], "Name");
        modelName = getChildText(dzPrinters[i], "ModelName");
        isConnected = getChildText(dzPrinters[i], "IsConnected") == "True";
        isLocal = getChildText(dzPrinters[i], "IsLocal") == "True";
        isAutoCutSupported = getChildText(dzPrinters[i], "IsAutoCutSupported") == "True";

        var dzPrinterInfo = new dymo.label.framework.DZPrinterInfo(name, modelName, isConnected, isLocal, isAutoCutSupported);
        addPrinterToCollection(dzPrinterInfo, result);
    }
    return result;
}




/** filters printers list by specified printer type
    @private
    @param {string} printerType
    @return {Array.<dymo.label.framework.PrinterInfo>}
*/
function getPrintersByType(printerType)
{
    var result = [];
     /** optionalProperty always contains an array or null
    * @type {?Array}
    */
    var printers = dymo.label.framework.getPrinters();
    printers = printers['byIndex']; // access array safely
    for (var i = 0; i < printers.length; i++)
    {
        var printer = printers[i];
        if (!!printer.printerType && printer.printerType == printerType)
            result.push(printer);
    }

    return result;
}

/** filters printers list by specified printer type
    @private
    @param {string} printerType    
	@return {Array.<dymo.label.framework.PrinterInfo>}    
*/
function getPrintersByTypeAsync(printerType)
{        
	return dymo.label.framework.getPrintersAsync().then(function(printers)
	{
        var result = [];        
		printers = printers['byIndex']; // access array safely
		for (var i = 0; i < printers.length; i++)
		{
			var printer = printers[i];
			if (!!printer.printerType && printer.printerType == printerType)
				result.push(printer);
		}
		return result;
	});	 
}

/** filters printers list, gets LabelWriter printers only
    @return {Array.<dymo.label.framework.LabelWriterPrinterInfo>}
    @export
*/
dymo.label.framework.getLabelWriterPrinters = function()
{
    return getPrintersByType("LabelWriterPrinter");
}

/** filters printers list, gets tape printers only
    @return {Array.<dymo.label.framework.TapePrinterInfo>}
    @export
*/
dymo.label.framework.getTapePrinters = function()
{
    return getPrintersByType("TapePrinter");
}

/** filters printers list, gets DZ printers only
    @return {Array.<dymo.label.framework.DZPrinterInfo>}
    @export
*/
dymo.label.framework.getDZPrinters = function () {
    return getPrintersByType("DZPrinter");
}

/** filters printers list, gets LabelWriter printers only
    @return {Array.<dymo.label.framework.LabelWriterPrinterInfo>}
    @export
*/
dymo.label.framework.getLabelWriterPrintersAsync = function()
{
	return getPrintersByTypeAsync("LabelWriterPrinter");
}

/** filters printers list, gets tape printers only
    @return {Array.<dymo.label.framework.TapePrinterInfo>}
    @export
*/
dymo.label.framework.getTapePrintersAsync = function()
{    
	return getPrintersByTypeAsync("TapePrinter");
}

/** filters printers list, gets DZ printers only
    @return {Array.<dymo.label.framework.DZPrinterInfo>}
    @export
*/
dymo.label.framework.getDZPrintersAsync = function ()
{    	
	return getPrintersByTypeAsync("DZPrinter");	
}


/** loads label content from a file or URL
 There are some considerations should be taken into account before using this function.
 Use it only then there are no other way to load label data, that in most cases should be done using openLabelXml()
 - full file name/url should be specified. The function will not honor relative pathes based on document.location.href
 - the fileName can be http:// or file:// urls. On Windows it can be a regular file name, like 'c:\users\desktop\address.label' 
 - the content of the label will be loaded synchronously. So if the remote server is down there will be a timeout.
 - any local file can be accessed/tried to be accessed. The function is not limited by any browser restrictions. 
   Though only a valid label file (according to label.xsd schema) can be loaded this still can be potential security concern.
 - the URL is not limited to same-site-origin browser policy - any url can be opened
 - the proxy settings are system default settings, not nessesary browser settings. TODO: fix it by providing proxy settings params into the library (same as DLS7) or read browser proxy settings (if possible) 
 returns Label object provides label manipulation methods

    @param {string} fileName
    return {dymo.label.framework.ILabel}
    @export
*/ 
dymo.label.framework.openLabelFile = function(fileName)
{
    return new dymo.label.framework.Label(_createFramework().openLabelFile(fileName));
}

/**
    @param {string} fileName
    return {dymo.label.framework.ILabel}
    @export
*/ 
dymo.label.framework.openLabelFileAsync = function(fileName)
{    
	return _createFramework().openLabelFileAsync(fileName).then(function(labelXml)
	{
		return new dymo.label.framework.Label(labelXml);
	});	 
}

/** loads label content from xml stream/string
 labelXml - label definition as xml string
 Note: it is a preferable way to load/open label files. Use XMLHttpRequest() or other standard browser methods to get xml string.
 returns Label object

    @param {string} labelXml
    return {dymo.label.framework.ILabel}
    @export
*/
dymo.label.framework.openLabelXml = function(labelXml)
{
    //alert('dymo.label.framework.openLabelXml: ' + labelXml);
    //goog.debug.Logger.getLogger('dymo.label.framework').info('dymo.label.framework.openLabelXml(): length ' + labelXml.length);

    var logger = new goog.debug.Logger('dymo.label.framework');
    logger.setLevel(goog.debug.Logger.Level.INFO);
    logger.info(labelXml);
    
    return new dymo.label.framework.Label(labelXml);
}


/**
    Contains a pair of 
    @constructor

    @param {string} printerUri
    @param {string} printerName
*/
//function NetworkPrinterName(printerUri, printerName) 
//{
//    this.printerUri = printerUri;
//    this.printerName = printerName;
//}


/** Splits network printer name into two parts, the printer's uri and a 
 'local' printer name

 @param {string} networkPrinterName
 @return {NetworkPrinterName} 
*/
/*
function splitNetworkPrinterName(networkPrinterName)
{
    var uri = new goog.Uri(networkPrinterName);
    var printerName = uri.getPath();
    if (printerName.length > 1 && printerName.charAt(0) == '/')
        printerName = printerName.slice(1);

    uri.setPath('');

    return new NetworkPrinterName(uri.toString(), printerName);
}
*/

/** Prints a label
// printerName - the printer to print on. A list of printers can be obtained by getPrinters()
// printParamsXml - printing parameters, like number of copies, print quality, etc. See PrintParams.xsd
// labelXml - label to print
// labelSetXml - LabelSet to print. LabelSet is used to print multiple labels with same layout but different data, e.g. multiple addresses.
//               Use LabelSetBuilder to create a LabelSet or construct xml manualy according to LabelSet.xsd

    @param {string} printerName
    @param {string} printParamsXml
    @param {string} labelXml
    @param {string} labelSetXml
    @return {undefined}
    @export
*/
dymo.label.framework.printLabel = function(printerName, printParamsXml, labelXml, labelSetXml)
{
    printParamsXml = printParamsXml || "";
    labelSetXml = labelSetXml || "";
    if (typeof(labelSetXml) != "string")
        labelSetXml = labelSetXml.toString();
        
    if (typeof(labelXml) == "undefined")
            throw new Error("printLabel(): labelXml parameter should be specified");

    if (typeof(labelXml) != "string")
        labelXml = labelXml.toString();

    var printers = dymo.label.framework.getPrinters();
    var printerInfo = printers[printerName];

    if (goog.isDefAndNotNull(printerInfo))
    {
        if (ASSUME_MOBILE || printerInfo.isNetworkPrinter())
            printLabelToNetworkPrinter(printerInfo, printParamsXml, labelXml, labelSetXml);
        else
            _createFramework().printLabel(printerInfo["name"], printParamsXml, labelXml, labelSetXml);
    }
    else
        throw new Error("printLabel(): unknown printer '" + printerName + "'");


    //if (!isNetworkPrinter(printerName))
    //    _createFramework().printLabel(printerName, printParamsXml, labelXml, labelSetXml);
    //else
    //{
    //    printLabelToNetworkPrinter(printerName, printParamsXml, labelXml, labelSetXml);
    //}
};




/** Prints a label and runs status checking in a loop

    @param {string} printerName the printer to print on. A list of printers can be obtained by getPrinters()
    @param {string} printParamsXml printing parameters, like number of copies, print quality, etc. See PrintParams.xsd
    @param {string} labelXml label to print
    @param {string} labelSetXml 
        LabelSet to print. LabelSet is used to print multiple labels with same layout but different data, e.g. multiple addresses. 
        Use LabelSetBuilder to create a LabelSet or construct xml manualy according to LabelSet.xsd
    @param {function(dymo.label.framework.PrintJob, dymo.label.framework.PrintJobStatusInfo): boolean} statusCallback
        Function to be called when a print job status is available.
        The function is called with one argument of type dymo.label.framework.PrintJobStatusInfo
        To continue polling the status the function should return true, false otherwise 
    @param {number} pollInterval poll interval in milliseconds
    @return {dymo.label.framework.PrintJob}
    @export
*/
dymo.label.framework.printLabelAndPollStatus = function(printerName, printParamsXml, labelXml, labelSetXml, statusCallback, pollInterval)
{
    var printJob = dymo.label.framework.printLabel2(printerName, printParamsXml, labelXml, labelSetXml);

    var statusChecker = function(pjs)
    {
        var callbackResult = statusCallback(printJob, pjs);
        if (!callbackResult)
            return;

        // schedule more status checking                    
        var delay = new goog.async.Delay(function()
        {
            printJob.getStatus(statusChecker);
            delay.dispose();
        }, pollInterval);
        delay.start();
    };

    printJob.getStatus(statusChecker);

    return printJob;
};
/** Prints a label and runs status checking in a loop

    @param {string} printerName the printer to print on. A list of printers can be obtained by getPrinters()
    @param {string} printParamsXml printing parameters, like number of copies, print quality, etc. See PrintParams.xsd
    @param {string} labelXml label to print
    @param {string} labelSetXml 
        LabelSet to print. LabelSet is used to print multiple labels with same layout but different data, e.g. multiple addresses. 
        Use LabelSetBuilder to create a LabelSet or construct xml manualy according to LabelSet.xsd
    @param {function(dymo.label.framework.PrintJob, dymo.label.framework.PrintJobStatusInfo): boolean} statusCallback
        Function to be called when a print job status is available.
        The function is called with one argument of type dymo.label.framework.PrintJobStatusInfo
        To continue polling the status the function should return true, false otherwise 
    @param {number} pollInterval poll interval in milliseconds   
	@return {goog.Promise} dymo.label.framework.PrintJob print job
    @export
*/
dymo.label.framework.printLabelAndPollStatusAsync = function(printerName, printParamsXml, labelXml, labelSetXml, statusCallback, pollInterval)
{    	
	return dymo.label.framework.printLabel2Async(printerName, printParamsXml, labelXml, labelSetXml).then(function(printJob){
		
		var statusChecker = function(pjs)
		{
			var callbackResult = statusCallback(printJob, pjs);
			if (!callbackResult)
				return;

			// schedule more status checking                    
			var delay = new goog.async.Delay(function()
			{
				printJob.getStatus(statusChecker);
				delay.dispose();
			}, pollInterval);
			delay.start();
		};

		printJob.getStatus(statusChecker);

		return printJob;
	});
};



/** Creates a label bitmap image can be used for label previewing
 Params:
 - labelXml - label to preview
 - renderParamsXml - rendering parameters, like shadow depth, label color, etc. See LabelRenderParams.xsd
 - printerName - printer name the preview is generated for. Thhe preview/output cna be different on different printers,
                 especially on tape printers with different print head size.
                 An empty string can be passed if it does not matter or important on whitch printer the label will be printed.
                 In this case a default printer metrics will be used that is LW400 for LabelWriter printers and LW400 DUO Tape for tape printers

    @param {string} labelXml
    @param {string} renderParamsXml
    @param {string} printerName
    @return {string}
    @export
*/
dymo.label.framework.renderLabel = function(labelXml, renderParamsXml, printerName)
{
    if (typeof(labelXml) == "undefined")
            throw new Error("renderLabel(): labelXml parameter should be specified");

    if (typeof(labelXml) != "string")
        labelXml = labelXml.toString();

    renderParamsXml = renderParamsXml || "";
    printerName = printerName || "";

    return _createFramework().renderLabel(labelXml, renderParamsXml, printerName);
};

/** Creates a label bitmap image can be used for label previewing
 Params:
 - labelXml - label to preview
 - renderParamsXml - rendering parameters, like shadow depth, label color, etc. See LabelRenderParams.xsd
 - printerName - printer name the preview is generated for. Thhe preview/output cna be different on different printers,
                 especially on tape printers with different print head size.
                 An empty string can be passed if it does not matter or important on whitch printer the label will be printed.
                 In this case a default printer metrics will be used that is LW400 for LabelWriter printers and LW400 DUO Tape for tape printers

    @param {string} labelXml
    @param {string} renderParamsXml
    @param {string} printerName
    @return {string}
    @export
*/
dymo.label.framework.renderLabelAsync = function(labelXml, renderParamsXml, printerName)
{
   	
	if (typeof(labelXml) == "undefined")
            throw new Error("renderLabelAsync(): labelXml parameter should be specified");

    if (typeof(labelXml) != "string")
        labelXml = labelXml.toString();

    renderParamsXml = renderParamsXml || "";
    printerName = printerName || "";
	
	return _createFramework().renderLabelAsync(labelXml, renderParamsXml, printerName);
};


/** Utility function to create a render label request object
    @param {string} requestId
    @param {string} statusId
    @param {string} statusMessage
    @param {string} imageData

    @return {Object}
*/
function createRenderLabelRequest(requestId, statusId, statusMessage, imageData)
{
    var result = {};
    result['requestId'] = requestId;
    result['imageData'] = imageData;
    result['statusId'] = statusId;
    result['statusMessage'] = statusMessage;

    return result;
}

/** Creates a label bitmap image can be used for label previewing
 Params:
 - labelXml - label to preview
 - renderParamsXml - rendering parameters, like shadow depth, label color, etc. See LabelRenderParams.xsd
 - printerName - printer name the preview is generated for. Thhe preview/output cna be different on different printers,
                 especially on tape printers with different print head size.
                 An empty string can be passed if it does not matter or important on whitch printer the label will be printed.
                 In this case a default printer metrics will be used that is LW400 for LabelWriter printers and LW400 DUO Tape for tape printers

    @param {string} labelXml
    @param {string} renderParamsXml
    @param {string} printerName
    @param {Function} callback
    @return {undefined}
    @export
*/
/*
dymo.label.framework.renderLabelAsync = function(labelXml, callback, renderParamsXml, printerName)
{
    if (typeof(labelXml) == "undefined")
            throw new Error("renderLabelAsync(): labelXml parameter should be specified");

    if (!callback)
        throw new Error("renderLabelAsync(): callback parameter should be specified");

    if (typeof(labelXml) != "string")
        labelXml = labelXml.toString();

    renderParamsXml = renderParamsXml || "";
    printerName = printerName || "";


    var printers = dymo.label.framework.getPrinters();
    var printerInfo = printers[printerName];


    // for 'local' printers call the Framework as usual
    if (!ASSUME_MOBILE && (!goog.isDefAndNotNull(printerName) || (goog.isDefAndNotNull(printerInfo) && !printerInfo.isNetworkPrinter())))
    {
        
		var result;
		try
		{
			var imageData = _createFramework().renderLabel(labelXml, renderParamsXml, printerName);
			result = createRenderLabelRequest('', 'Ready', '', imageData);
		}
		catch(e)
		{
			result = createRenderLabelRequest('', 'Error', e.message || e, '');
		}

		callback(result);
		
        return;
    }

    if (!goog.isDefAndNotNull(printerInfo))
        throw new Error("printLabel(): unknown printer '" + printerName + "'");

    // now we know it is a 'network' printer. Send a requist to it

    var requestId = dymo.uuid.uuid();
    // send print data
    goog.net.IframeIo.send(
        goog.Uri.resolve(printerInfo.printerUri, 'renderLabel'),
        null,
        'POST',
        true,
        {
            'requestId': requestId,
            'printerName': printerInfo.originalPrinterName,
            'labelXml': labelXml,
            'renderParamsXml': renderParamsXml
        });



    // set a timer to check for the imageData every second
    // use 30 seconds timeout by default TODO: pass timeout as a parameter
    var delay;
    var startTime = new Date().getTime();
    var timeout = 30000; // 30 seconds
    var firstDelay = 500;
    var notFirstDelay = 1000;

    var delayAction = function()
    {
        if (new Date().getTime() - startTime > timeout)
        {
            // timeout   
            delay.dispose();
            delay = null;
            callback(createRenderLabelRequest(requestId, 'Timeout', '', ''));
            return;
        }

        // try to get data
        var jsonp2 = new goog.net.Jsonp(goog.Uri.resolve(printerInfo.printerUri, 'getRenderLabelStatus'), 'callback');
        jsonp2.send(
            {'requestId': requestId}, 
            function(rlr) 
            {
                // check status
                var statusId = rlr['statusId']
                if (statusId == 'NotStarted' || statusId == 'Processing')
                {
                    // wait again
                    delay.stop();
                    delay.start(notFirstDelay); // all other requests are with 1 second delay
                }
                else
                {
                    // return result
                    delay.dispose();
                    delay = null;
                    callback(rlr);
                }
            },
            function()
            {
                // some error happended, wait again until timeout
                delay.start(notFirstDelay); // all other requests are with 1 second delay
            });
    };

    delay = new goog.async.Delay(delayAction, firstDelay); 
    delay.start();
};

*/

/** Loads an image from url/file and returns it as base64-encoded png stream.
// Note: the same comments as for openLabelFile() is applied to this function as well

    @param {string} imageUri
    @return {string}
    @export
*/    
dymo.label.framework.loadImageAsPngBase64 = function(imageUri)
{
    return _createFramework().loadImageAsPngBase64(imageUri);
};

/** Loads an image from url/file and returns it as base64-encoded png stream.
// Note: the same comments as for openLabelFile() is applied to this function as well

    @param {string} imageUri
    @return {string}
    @export
*/    
dymo.label.framework.loadImageAsPngBase64Async = function(imageUri)
{
	return _createFramework().loadImageAsPngBase64Async(imageUri);
};

/** Creates an xml stream suatable to pass to printLabel() function as printParamsXml parameter
// Created printing parameters are for printing on LabelWriter printers
// Parameters:
// - params - an JavaScript object with following properties (not all properties have to be defined, if a property is not defined a default value will be used)
//      params.copies - number of copies to print
//      params.jobTitle - print job title/description
//      params.flowDirection - prints label content as left-to-right or right-to-left use FlowDirection enum to specify values
//      params.printQuality - printing quality, one of 'Text', 'BarcodeAndGraphics', or 'Auto'
//      params.twinTurboRoll - the roll to print on if the printer is TwinTurbo. One of 'Left", 'Right', or 'Auto'

    @param {LabelWriterPrintParams} params
    @return {string}
    @export
*/
dymo.label.framework.createLabelWriterPrintParamsXml = function(params)
{
    if (!params)
        return "";

    var doc = dymo.xml.parse("<LabelWriterPrintParams/>");
    var root = doc.documentElement;

    if (params.copies)
        dymo.xml.appendElement(root, "Copies", params.copies.toString());

    if (params.jobTitle)
        dymo.xml.appendElement(root, "JobTitle", params.jobTitle);

    if (params.flowDirection)
        dymo.xml.appendElement(root, "FlowDirection", params.flowDirection);

    if (params.printQuality)
        dymo.xml.appendElement(root, "PrintQuality", params.printQuality);

    if (params.twinTurboRoll)
        dymo.xml.appendElement(root, "TwinTurboRoll", params.twinTurboRoll);

    //var result = Xml.serialize(doc);
    //alert(result);
    //return result;

    return dymo.xml.serialize(doc);
}

/** Creates an xml stream suatable to pass to printLabel() function as printParamsXml parameter
// Created printing parameters are for printing on Tape printers
// Parameters:
// - params - an JavaScript object with following properties (not all properties have to be defined, if a property is not defined a default value will be used)
//      params.copies - number of copies to print
//      params.jobTitle - print job title/description
//      params.flowDirection - prints label content as left-to-right or right-to-left use FlowDirection enum to specify values
//      params.alignment - lable alignment. One of 'Left', 'Center', or 'Right'
//      params.cutMode - cut mode if auto-cut is supported by the printer. One of 'AutoCut" or 'ChainMarks'

    @param {TapePrintParams} params
    @return {string}
    @export

*/
dymo.label.framework.createTapePrintParamsXml = function(params)
{
    if (!params)
        return "";

    var doc = dymo.xml.parse("<TapePrintParams/>");
    var root = doc.documentElement;

    if (params.copies)
        dymo.xml.appendElement(root, "Copies", params.copies.toString());

    if (params.jobTitle)
        dymo.xml.appendElement(root, "JobTitle", params.jobTitle);

    if (params.flowDirection)
        dymo.xml.appendElement(root, "FlowDirection", params.flowDirection);

    if (params.alignment)
        dymo.xml.appendElement(root, "Alignment", params.alignment);

    if (params.cutMode)
        dymo.xml.appendElement(root, "CutMode", params.cutMode);

    return dymo.xml.serialize(doc);
}

/** Creates an xml stream suatable to pass to printLabel() function as printParamsXml parameter
// Created printing parameters are for printing on DZ printers
// Parameters:
// - params - an JavaScript object with following properties (not all properties have to be defined, if a property is not defined a default value will be used)
//      params.copies - number of copies to print
//      params.jobTitle - print job title/description
//      params.flowDirection - prints label content as left-to-right or right-to-left use FlowDirection enum to specify values
//      params.alignment - lable alignment. One of 'Left', 'Center', or 'Right'
//      params.cutMode - cut mode if auto-cut is supported by the printer. One of 'AutoCut" or 'ChainMarks'

    @param {DZPrintParams} params
    @return {string}
    @export

*/
dymo.label.framework.createDZPrintParamsXml = function (params) {
    if (!params)
        return "";

    var doc = dymo.xml.parse("<DZPrintParams/>");
    var root = doc.documentElement;

    if (params.copies)
        dymo.xml.appendElement(root, "Copies", params.copies.toString());

    if (params.jobTitle)
        dymo.xml.appendElement(root, "JobTitle", params.jobTitle);

    if (params.flowDirection)
        dymo.xml.appendElement(root, "FlowDirection", params.flowDirection);

    if (params.alignment)
        dymo.xml.appendElement(root, "Alignment", params.alignment);

    if (params.cutMode)
        dymo.xml.appendElement(root, "CutMode", params.cutMode);

    return dymo.xml.serialize(doc);
}


